using EchoOfTheTimes.SceneManagement;
using EchoOfTheTimes.ScriptableObjects;
using EchoOfTheTimes.ScriptableObjects.Persistence;
using System;
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Zenject;

namespace EchoOfTheTimes.Persistence
{
    public class PersistenceService : MonoBehaviour
    {
        public static Action<int> OnLevelCompleted { get; private set; }
        public static Action OnExitToMainMenu { get; private set; }

        private SaveLoadService _saveLoadService;

        public string LastLoadedLevel { get; private set; }

        private PresetType _presetType;

        private PlayerData _defaultData;
        private PlayerData _allUnlockData;

        private void OnDestroy()
        {
            OnLevelCompleted -= HandleLevelCompleted;
            OnExitToMainMenu -= HandleExitToMainMenu;
        }

        [Inject]
        private void Construct()
        {
            OnLevelCompleted += HandleLevelCompleted;
            OnExitToMainMenu += HandleExitToMainMenu;

            LoadPresets();

            _presetType = (Resources.Load(@"ScriptableObjects/BootstrapSettings") as BootstrapSettingsScriptableObject).UsedSavingPreset;

            _saveLoadService = _presetType switch
            {
                PresetType.SavedFile => new SaveLoadService(_defaultData),
                PresetType.Default => new SaveLoadService(_defaultData, true),
                PresetType.AllUnlock => new SaveLoadService(_allUnlockData, true),
                _ => throw new NotImplementedException($"Not implemented {nameof(PresetType)} with value: '{_presetType}'!"),
            };

            Debug.Log($"Enable {nameof(_saveLoadService)} with preset: {_presetType}!");
        }

        private void LoadPresets()
        {
            _defaultData = LoadPresetFromResources(@"ScriptableObjects/Persistence/PlayerDataDefaultPreset-AutoGenerated");
            _allUnlockData = LoadPresetFromResources(@"ScriptableObjects/Persistence/PlayerDataUnlockedAllPreset-AutoGenerated");
        }

        private PlayerData LoadPresetFromResources(string path)
        {
            var preset = Resources.LoadAsync(path).asset as PlayerDataPresetScriptableObject;

            if (preset == null)
            {
                throw new NullReferenceException($"You need to create '{path.Split(Path.PathSeparator)[^1]}' first!");
            }

            return preset.Data;
        }

        private void HandleLevelCompleted(int collected)
        {
            var newDataToSave = _saveLoadService.DataToSave;

            if (string.IsNullOrEmpty(LastLoadedLevel))
            {
                LastLoadedLevel = _saveLoadService.DataToSave.Data[1].Levels[0].FullName;
            }

            // пометить текущий уровень как пройденный
            //var lastLoadedChapterTitle = _lastLoadedLevel.ChapterName;
            //var lastLoadedLevelName = _lastLoadedLevel.LevelName;
            var lastLoadedChapterTitle = LastLoadedLevel.Split('|')[0];
            var lastLoadedLevelName = LastLoadedLevel.Split('|')[1];
            int lastLoadedChapterIndex = -1;
            int lastLoadedLevelIndex = -1;
            for (int i = 0; i < newDataToSave.Data.Count; i++)
            {
                if (newDataToSave.Data[i].Title == lastLoadedChapterTitle)
                {
                    var lastLoadedChapter = newDataToSave.Data[i];
                    lastLoadedChapterIndex = i;
                    for (int j = 0; j < lastLoadedChapter.Levels.Count; j++)
                    {
                        if (lastLoadedChapter.Levels[j].LevelName == lastLoadedLevelName)
                        {
                            lastLoadedChapter.Levels[j].LevelStatus = StatusType.Completed;
                            lastLoadedChapter.Levels[j].Collected = collected;
                            lastLoadedLevelIndex = j;
                            break;
                        }
                    }

                    break;
                }
            }

            // Проверить все главы -- одна из них может открыться, так как собрано нужное кол-во коллектаблов
            for (int i = 1; i < newDataToSave.Data.Count; i++)
            {
                if (IsChapterComplete(newDataToSave, i))
                {
                    newDataToSave.Data[i + 1].ChapterStatus = StatusType.Unlocked;
                    newDataToSave.Data[i + 1].Levels[0].LevelStatus = StatusType.Unlocked;
                }
            }

            // пометить следующий как открытый
            // возможны случаи:
            // ЕСЛИ УРОВЕНЬ В НАЧАЛЕ ИЛИ В СЕРЕДИНЕ ГЛАВЫ
            // ЕСЛИ ПОСЛЕДНИЙ УРОВЕНЬ ГЛАВЫ
            // ЕСЛИ ПОСЛЕДНИЙ УРОВЕНЬ ПОСЛЕДНЕЙ ГЛАВЫ

            // если не последний уровень на главе
            if (lastLoadedLevelIndex < newDataToSave.Data[lastLoadedChapterIndex].Levels.Count - 1)
            {
                lastLoadedLevelIndex++;
                newDataToSave.Data[lastLoadedChapterIndex].Levels[lastLoadedLevelIndex].LevelStatus = StatusType.Unlocked;
            }
            else
            {
                // если не последняя глава
                if (lastLoadedChapterIndex < newDataToSave.Data.Count - 1)
                {
                    newDataToSave.Data[lastLoadedChapterIndex].ChapterStatus = StatusType.Completed;

                    if (IsChapterComplete(newDataToSave, lastLoadedChapterIndex))
                    {
                        lastLoadedChapterIndex++;
                        newDataToSave.Data[lastLoadedChapterIndex].ChapterStatus = StatusType.Unlocked;
                        newDataToSave.Data[lastLoadedChapterIndex].Levels[0].LevelStatus = StatusType.Unlocked;
                        lastLoadedLevelIndex = 0;
                    }
                }
                else
                {
                    newDataToSave.Data[lastLoadedChapterIndex].ChapterStatus = StatusType.Completed;
                }
            }

            //_lastLoadedLevel = newDataToSave.Data[lastLoadedChapterIndex].Levels[lastLoadedLevelIndex];
            LastLoadedLevel = newDataToSave.Data[lastLoadedChapterIndex].Levels[lastLoadedLevelIndex].FullName;

            newDataToSave.LastLoadedLevelFullName = LastLoadedLevel;

            // сохранить данные
            if (_presetType == PresetType.SavedFile)
            {
                _saveLoadService.DataToSave = newDataToSave;
                _saveLoadService.Save();
            }
        }

        private void HandleExitToMainMenu()
        {
            // сохранить данные
            if (_presetType == PresetType.SavedFile)
            {
                _saveLoadService.Save();
            }
        }

        public List<GameChapter> GetData() => _saveLoadService.DataToSave.Data;

        public bool GetSettings() => _saveLoadService.DataToSave.SoundsMuted;

        public void SetAndSaveSetttings(bool isMuted)
        {
            _saveLoadService.DataToSave.SoundsMuted = isMuted;

            if (_presetType == PresetType.SavedFile)
            {
                _saveLoadService.Save();
            }
        }

        public void UpdateLastLoadedLevel(GameLevel level) => LastLoadedLevel = level.FullName;

        public GameLevel GetLevel(string chapterTitle, string levelName)
        {
            var chapterIndex = _saveLoadService.DataToSave.Data.FindIndex((chapter) => chapter.Title == chapterTitle);
            var levelIndex = _saveLoadService.DataToSave.Data[chapterIndex].Levels.FindIndex(
                (level) => level.LevelName == levelName);

            return _saveLoadService.DataToSave.Data[chapterIndex].Levels[levelIndex];
        }

        private bool IsChapterComplete(PlayerData playerData, int chapterIndex)
        {
            int requiredSum = 0;
            int progress = 0;

            for (int i = 0; i < chapterIndex + 1; i++)
            {
                for (int j = 0; j < playerData.Data[i].Levels.Count; j++)
                {
                    requiredSum += playerData.Data[i].Levels[j].TotalCollectables;
                    progress += playerData.Data[i].Levels[j].Collected;
                }
            }

            if (progress == requiredSum)
            {
                return true;
            }

            return false;
        }
    }
}